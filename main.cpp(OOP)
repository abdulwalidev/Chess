#include <iostream>
#include <fstream>
#include <string>
#include <cctype>
#include <cmath>
#include <sstream>
#include <windows.h>    
#include <conio.h>
#include <cstdlib>
#include <ctime>

using namespace std;

// Base class for authentication and user management
class User {
private:
    string username;
    string passwordHash;
    int elo;
    
    string hashPassword(const string& password) {
        int hash = 0;
        for (char c : password) {
            hash = (hash * 31 + c) % 1000000007;
        }
        return to_string(hash);
    }
    
    bool userExists(const string& username) {
        ifstream file("users.txt");
        string line;
        while (getline(file, line)) {
            istringstream iss(line);
            string user;
            iss >> user;
            if (user == username) return true;
        }
        return false;
    }

public:
    User() : elo(1200) {}
    
    // Encapsulation: Getters and setters
    string getUsername() const { return username; }
    int getElo() const { return elo; }
    void setElo(int newElo) { elo = newElo; }
    
    bool registerUser() {
        string password;
        cout << "\nChoose a username (4-20 characters): ";
        cin >> username;
        
        if (username.length() < 4 || username.length() > 20) {
            cout << "Username must be 4-20 characters.\n";
            return false;
        }

        if (userExists(username)) {
            cout << "Username already exists.\n";
            return false;
        }

        cout << "Choose a password (minimum 8 characters): ";
        char ch;
        password = "";
        while ((ch = _getch()) != '\r') {
            if (ch == '\b') {
                if (!password.empty()) {
                    cout << "\b \b";
                    password.pop_back();
                }
            } else {
                password.push_back(ch);
                cout << '*';
            }
        }
        cout << endl;
        
        if (password.length() < 8) {
            cout << "Password must be at least 8 characters.\n";
            return false;
        }

        ofstream file("users.txt", ios::app);
        file << username << " " << hashPassword(password) << " 1200\n";
        cout << "Registration successful! Starting ELO: 1200\n";
        this->passwordHash = hashPassword(password);
        this->elo = 1200;
        return true;
    }
    
    bool login() {
        string password;
        cout << "\nUsername: ";
        cin >> username;

        cout << "Password: ";
        char ch;
        password = "";
        while ((ch = _getch()) != '\r') {
            if (ch == '\b') {
                if (!password.empty()) {
                    cout << "\b \b";
                    password.pop_back();
                }
            } else {
                password.push_back(ch);
                cout << '*';
            }
        }
        cout << endl;

        ifstream file("users.txt");
        string line;
        string hashed = hashPassword(password);

        while (getline(file, line)) {
            istringstream iss(line);
            string userInFile, passHash;
            int eloValue;
            iss >> userInFile >> passHash >> eloValue;
            if (userInFile == username && passHash == hashed) {
                this->passwordHash = passHash;
                this->elo = eloValue;
                cout << "\nLogin successful! ELO: " << eloValue << "\n";
                return true;
            }
        }
        cout << "\nLogin failed.\n";
        return false;
    }
};

// Abstract base class for pieces (demonstrating abstraction)
class Piece {
protected:
    char symbol;
    bool isWhite;
    
public:
    Piece(char s, bool white) : symbol(s), isWhite(white) {}
    virtual ~Piece() {}
    
    char getSymbol() const { return symbol; }
    bool getIsWhite() const { return isWhite; }
    
    // Pure virtual function for move validation (abstraction)
    virtual bool isValidMove(int srcRow, int srcCol, int destRow, int destCol, char board[8][8]) = 0;
};

// Concrete piece classes (demonstrating inheritance and polymorphism)
class Pawn : public Piece {
public:
    Pawn(bool white) : Piece(white ? 'P' : 'p', white) {}
    
    bool isValidMove(int srcRow, int srcCol, int destRow, int destCol, char board[8][8]) override {
        int direction = isWhite ? -1 : 1;
        bool isOpponentPiece = isWhite ? islower(board[destRow][destCol]) : isupper(board[destRow][destCol]);

        if (srcCol == destCol && board[destRow][destCol] == '-') {
            return (destRow - srcRow == direction) ||
                (srcRow == (isWhite ? 6 : 1) && destRow - srcRow == 2 * direction && board[srcRow + direction][srcCol] == '-');
        }

        if (abs(srcCol - destCol) == 1 && destRow - srcRow == direction && isOpponentPiece) {
            return true;
        }
        return false;
    }
};

class Rook : public Piece {
public:
    Rook(bool white) : Piece(white ? 'R' : 'r', white) {}
    
    bool isValidMove(int srcRow, int srcCol, int destRow, int destCol, char board[8][8]) override {
        if (srcRow != destRow && srcCol != destCol) return false;
        int rowStep = (srcRow < destRow) ? 1 : (srcRow > destRow ? -1 : 0);
        int colStep = (srcCol < destCol) ? 1 : (srcCol > destCol ? -1 : 0);
        for (int i = srcRow + rowStep, j = srcCol + colStep; i != destRow || j != destCol; i += rowStep, j += colStep) {
            if (board[i][j] != '-') return false;
        }
        char target = board[destRow][destCol];
        return target == '-' || (isWhite ? islower(target) : isupper(target));
    }
};

// Game engine class encapsulating all game logic
class ChessGame {
private:
    char board[8][8];
    bool possible[8][8];
    int cursorRow, cursorCol;
    bool pieceSelected;
    int selectedRow, selectedCol;
    char currentPlayer;
    
    // Castling flags
    bool whiteKingMoved, blackKingMoved;
    bool whiteRookLeftMoved, whiteRookRightMoved;
    bool blackRookLeftMoved, blackRookRightMoved;
    
    User* player1;
    User* player2;
    
    void initializeBoard() {
        for (int i = 0; i < 8; ++i) {
            board[1][i] = 'p';
            board[6][i] = 'P';
        }
        const char white_pieces[] = {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'};
        const char black_pieces[] = {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'};
        for (int i = 0; i < 8; ++i) {
            board[0][i] = black_pieces[i];
            board[7][i] = white_pieces[i];
        }
        for (int i = 2; i < 6; ++i)
            for (int j = 0; j < 8; ++j)
                board[i][j] = '-';
    }
    
    void setColor(int color) {
        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);
    }
    
    void drawBoard() {
        const int padding = 10;
        cout << string(padding + 7, ' ') << "  a b c d e f g h\n";
        for (int i = 7; i >= 0; --i) {
            cout << string(padding + 7, ' ') << i + 1 << " ";
            for (int j = 0; j < 8; ++j) {
                char piece = board[i][j];
                bool isCursor = (i == cursorRow && j == cursorCol);
                bool isSelected = pieceSelected && i == selectedRow && j == selectedCol;
                bool isPossible = possible[i][j];

                if (piece == '-') setColor(8);
                else if (isupper(piece)) setColor(15);
                else setColor(11);

                if (isSelected) setColor(79);
                else if (isCursor) setColor(160);
                else if (isPossible) setColor(10);

                cout << (piece == '-' ? "_ " : string(1, piece) + " ");
                setColor(7);
            }
            cout << i + 1 << "\n";
        }
        cout << string(padding + 7, ' ') << "  a b c d e f g h\n";
    }
    
    bool isPathClear(int row, int col1, int col2) {
        if (col1 > col2) swap(col1, col2);
        for (int c = col1 + 1; c < col2; ++c)
            if (board[row][c] != '-') return false;
        return true;
    }
    
    bool isCastlingMove(int srcRow, int srcCol, int destRow, int destCol, char player) {
        if (player == 'w' && srcRow == 7 && srcCol == 4 && destRow == 7 && (destCol == 6 || destCol == 2)) {
            if (whiteKingMoved) return false;
            if (destCol == 6 && !whiteRookRightMoved && board[7][7] == 'R' && isPathClear(7, 4, 7)) return true;
            if (destCol == 2 && !whiteRookLeftMoved && board[7][0] == 'R' && isPathClear(7, 0, 4)) return true;
        }
        if (player == 'b' && srcRow == 0 && srcCol == 4 && destRow == 0 && (destCol == 6 || destCol == 2)) {
            if (blackKingMoved) return false;
            if (destCol == 6 && !blackRookRightMoved && board[0][7] == 'r' && isPathClear(0, 4, 7)) return true;
            if (destCol == 2 && !blackRookLeftMoved && board[0][0] == 'r' && isPathClear(0, 0, 4)) return true;
        }
        return false;
    }
    
    bool isValidMove(int srcRow, int srcCol, int destRow, int destCol, char player) {
        if (srcRow == destRow && srcCol == destCol) return false;
        char piece = board[srcRow][srcCol];
        if (player == 'w' && !isupper(piece)) return false;
        if (player == 'b' && !islower(piece)) return false;
        
        // Polymorphism demonstration - different piece types handle validation differently
        piece = tolower(piece);
        switch (piece) {
            case 'p': {
                Pawn p(player == 'w');
                return p.isValidMove(srcRow, srcCol, destRow, destCol, board);
            }
            case 'r': {
                Rook r(player == 'w');
                return r.isValidMove(srcRow, srcCol, destRow, destCol, board);
            }
            case 'n': return isValidKnightMove(srcRow, srcCol, destRow, destCol, player);
            case 'b': return isValidBishopMove(srcRow, srcCol, destRow, destCol, player);
            case 'q': return isValidQueenMove(srcRow, srcCol, destRow, destCol, player);
            case 'k': return isValidKingMove(srcRow, srcCol, destRow, destCol, player);
            default: return false;
        }
    }
    
    // Simplified legacy move validation methods
    bool isValidKnightMove(int srcRow, int srcCol, int destRow, int destCol, char player) {
        int dr = abs(srcRow - destRow), dc = abs(srcCol - destCol);
        char target = board[destRow][destCol];
        return (dr == 2 && dc == 1 || dr == 1 && dc == 2) &&
            (target == '-' || (player == 'w' ? islower(target) : isupper(target)));
    }
    
    bool isValidBishopMove(int srcRow, int srcCol, int destRow, int destCol, char player) {
        if (abs(srcRow - destRow) != abs(srcCol - destCol)) return false;
        int rowStep = (srcRow < destRow) ? 1 : -1;
        int colStep = (srcCol < destCol) ? 1 : -1;
        for (int i = srcRow + rowStep, j = srcCol + colStep; i != destRow; i += rowStep, j += colStep)
            if (board[i][j] != '-') return false;
        char target = board[destRow][destCol];
        return target == '-' || (player == 'w' ? islower(target) : isupper(target));
    }
    
    bool isValidQueenMove(int srcRow, int srcCol, int destRow, int destCol, char player) {
        Rook r(player == 'w');
        return r.isValidMove(srcRow, srcCol, destRow, destCol, board) ||
            isValidBishopMove(srcRow, srcCol, destRow, destCol, player);
    }
    
    bool isValidKingMove(int srcRow, int srcCol, int destRow, int destCol, char player) {
        if (isCastlingMove(srcRow, srcCol, destRow, destCol, player)) return true;
        int dr = abs(srcRow - destRow), dc = abs(srcCol - destCol);
        char target = board[destRow][destCol];
        return dr <= 1 && dc <= 1 &&
            (target == '-' || (player == 'w' ? islower(target) : isupper(target)));
    }
    
    bool isKingInCheck(char player) {
        char king = (player == 'w') ? 'K' : 'k';
        int kr = -1, kc = -1;
        for (int i = 0; i < 8; ++i)
            for (int j = 0; j < 8; ++j)
                if (board[i][j] == king) { kr = i; kc = j; break; }
        char opponent = (player == 'w') ? 'b' : 'w';
        for (int i = 0; i < 8; ++i)
            for (int j = 0; j < 8; ++j)
                if ((opponent == 'w' && isupper(board[i][j])) ||
                    (opponent == 'b' && islower(board[i][j])))
                    if (isValidMove(i, j, kr, kc, opponent)) return true;
        return false;
    }
    
    bool isCheckmate(char player) {
        if (!isKingInCheck(player)) return false;
        for (int i = 0; i < 8; ++i)
            for (int j = 0; j < 8; ++j) {
                char piece = board[i][j];
                if ((player == 'w' && !isupper(piece)) || (player == 'b' && !islower(piece))) continue;
                for (int ni = 0; ni < 8; ++ni)
                    for (int nj = 0; nj < 8; ++nj)
                        if (isValidMove(i, j, ni, nj, player)) {
                            char backup = board[ni][nj];
                            board[ni][nj] = board[i][j];
                            board[i][j] = '-';
                            bool stillCheck = isKingInCheck(player);
                            board[i][j] = board[ni][nj];
                            board[ni][nj] = backup;
                            if (!stillCheck) return false;
                        }
            }
        return true;
    }
    
    void updateEloRatings(User& winner, User& loser) {
        double expectedA = 1.0 / (1.0 + pow(10, (loser.getElo() - winner.getElo()) / 400.0));
        int k = 32;
        int newWinnerElo = winner.getElo() + k * (1 - expectedA);
        int newLoserElo = loser.getElo() + k * (0 - (1 - expectedA));
        if (newLoserElo < 100) newLoserElo = 100;
        winner.setElo(newWinnerElo);
        loser.setElo(newLoserElo);
    }
    
    void saveUserElos() {
        ifstream inFile("users.txt");
        ofstream outFile("users_temp.txt");
        string line;

        while (getline(inFile, line)) {
            istringstream iss(line);
            string username, passHash;
            int elo;
            iss >> username >> passHash >> elo;

            if (username == player1->getUsername()) {
                outFile << username << " " << passHash << " " << player1->getElo() << "\n";
            } else if (username == player2->getUsername()) {
                outFile << username << " " << passHash << " " << player2->getElo() << "\n";
            } else {
                outFile << line << "\n";
            }
        }

        inFile.close();
        outFile.close();
        remove("users.txt");
        rename("users_temp.txt", "users.txt");
    }

public:
    ChessGame(User* p1, User* p2) : player1(p1), player2(p2), currentPlayer('w'), 
        cursorRow(7), cursorCol(0), pieceSelected(false),
        whiteKingMoved(false), blackKingMoved(false),
        whiteRookLeftMoved(false), whiteRookRightMoved(false),
        blackRookLeftMoved(false), blackRookRightMoved(false) {
        initializeBoard();
        for (int i = 0; i < 8; ++i)
            for (int j = 0; j < 8; ++j)
                possible[i][j] = false;
    }
    
    void play() {
        bool gameOver = false;
        
        while (!gameOver) {
            system("cls");
            drawBoard();
            User& currentPlayerUser = (currentPlayer == 'w') ? *player1 : *player2;
            User& otherPlayerUser = (currentPlayer == 'w') ? *player2 : *player1;

            cout << endl << "\t        -> " << currentPlayerUser.getUsername() << "'s Turn ("
                << (currentPlayer == 'w' ? "UpperCase" : "LowerCase") << ") - ELO: "
                << currentPlayerUser.getElo() << "\n";

            if (isCheckmate(currentPlayer)) {
                cout << "\n\t CHECKMATE! " << otherPlayerUser.getUsername()
                    << " (" << (currentPlayer == 'w' ? "LowerCase" : "UpperCase") << ") wins!\n";

                updateEloRatings(otherPlayerUser, currentPlayerUser);

                cout << "\n\t New ELO ratings:\n";
                cout << "\t " << player1->getUsername() << ": " << player1->getElo() << "\n";
                cout << "\t " << player2->getUsername() << ": " << player2->getElo() << "\n";

                saveUserElos();
                cout << "\t Press any key to exit...";
                _getch();
                gameOver = true;
                continue;
            } else if (isKingInCheck(currentPlayer)) {
                cout << "\n\t " << currentPlayerUser.getUsername() << " ("
                    << (currentPlayer == 'w' ? "UpperCase" : "LowerCase") << ") is in CHECK!";
            }

            handleInput(gameOver);
        }
    }
    
private:
    void handleInput(bool& gameOver) {
        int ch = _getch();
        if (ch == 224) {
            int arrow = _getch();
            if (arrow == 72 && cursorRow < 7) cursorRow++;
            else if (arrow == 80 && cursorRow > 0) cursorRow--;
            else if (arrow == 75 && cursorCol > 0) cursorCol--;
            else if (arrow == 77 && cursorCol < 7) cursorCol++;
        } else if (ch == 13) {
            handleSelection();
        } else if (ch == 'q' || ch == 'Q') {
            gameOver = true;
        }
    }
    
    void handleSelection() {
        if (!pieceSelected) {
            if ((currentPlayer == 'w' && isupper(board[cursorRow][cursorCol])) ||
                (currentPlayer == 'b' && islower(board[cursorRow][cursorCol]))) {
                selectedRow = cursorRow;
                selectedCol = cursorCol;
                pieceSelected = true;
                calculatePossibleMoves();
            }
        } else {
            if (isValidMove(selectedRow, selectedCol, cursorRow, cursorCol, currentPlayer)) {
                makeMove();
            }
            pieceSelected = false;
            clearPossibleMoves();
        }
    }
    
    void calculatePossibleMoves() {
        for (int i = 0; i < 8; ++i)
            for (int j = 0; j < 8; ++j)
                possible[i][j] = isValidMove(selectedRow, selectedCol, i, j, currentPlayer);
    }
    
    void clearPossibleMoves() {
        for (int i = 0; i < 8; ++i)
            for (int j = 0; j < 8; ++j)
                possible[i][j] = false;
    }
    
    void makeMove() {
        char movedPiece = board[selectedRow][selectedCol];
        char captured = board[cursorRow][cursorCol];
        bool castling = isCastlingMove(selectedRow, selectedCol, cursorRow, cursorCol, currentPlayer);

        board[cursorRow][cursorCol] = movedPiece;
        board[selectedRow][selectedCol] = '-';
        if (castling) performCastling(cursorRow, cursorCol);

        if (isKingInCheck(currentPlayer)) {
            // Undo move
            board[selectedRow][selectedCol] = movedPiece;
            board[cursorRow][cursorCol] = captured;
            if (castling) performCastling(cursorRow, cursorCol);
            cout << "\nInvalid move! King would be in check.\n";
        } else {
            updateCastlingFlags(movedPiece);
            handlePromotion(movedPiece);
            currentPlayer = (currentPlayer == 'w') ? 'b' : 'w';
        }
    }
    
    void performCastling(int row, int destCol) {
        if (destCol == 6) {
            board[row][5] = board[row][7];
            board[row][7] = '-';
        } else if (destCol == 2) {
            board[row][3] = board[row][0];
            board[row][0] = '-';
        }
    }
    
    void updateCastlingFlags(char movedPiece) {
        if (movedPiece == 'K') whiteKingMoved = true;
        if (movedPiece == 'k') blackKingMoved = true;
        if (movedPiece == 'R' && selectedCol == 0 && selectedRow == 7) whiteRookLeftMoved = true;
        if (movedPiece == 'R' && selectedCol == 7 && selectedRow == 7) whiteRookRightMoved = true;
        if (movedPiece == 'r' && selectedCol == 0 && selectedRow == 0) blackRookLeftMoved = true;
        if (movedPiece == 'r' && selectedCol == 7 && selectedRow == 0) blackRookRightMoved = true;
    }
    
    void handlePromotion(char movedPiece) {
        if ((movedPiece == 'P' && cursorRow == 0) || (movedPiece == 'p' && cursorRow == 7)) {
            board[cursorRow][cursorCol] = (currentPlayer == 'w') ? 'Q' : 'q';
        }
    }
};

// Menu system class for user interface
class MenuSystem {
private:
    void printTitle() {
        cout << "==============================\n";
        cout << "     Welcome to CLI Chess     \n";
        cout << "==============================\n";
    }
    
    void printMenu(int selected) {
        system("cls");
        printTitle();
        string options[] = {"Login", "Register", "Exit"};
        cout << "\nUse UP/DOWN arrows to navigate, ENTER to select:\n\n";
        for (int i = 0; i < 3; ++i) {
            if (i == selected) cout << " > ";
            else cout << "   ";
            cout << options[i] << "\n";
        }
    }

public:
    int navigateMenu() {
        int selected = 0;
        while (true) {
            printMenu(selected);
            int key = _getch();

            if (key == 224) {
                key = _getch();
                if (key == 72 && selected > 0) selected--;
                else if (key == 80 && selected < 2) selected++;
            } else if (key == 13) {
                return selected + 1;
            }
        }
    }
    
    void pause() {
        cout << "\nPress any key to continue...";
        _getch();
    }
};

int main() {
    srand(time(NULL));
    MenuSystem menu;
    User player1, player2;
    
    cout << "Welcome to CLI Chess with ELO Rating!\n";
    cout << "Two players need to log in to play.\n\n";

    // Player 1 login shenanigans
    cout << "PLAYER 1 (UpperCase/White):\n";
    while (true) {
        int choice = menu.navigateMenu();
        if (choice == 1) {
            if (player1.login()) break;
            menu.pause();
        } else if (choice == 2) {
            player1.registerUser();
            menu.pause();
        } else {
            cout << "Exiting...\n";
            return 0;
        }
    }

    // Player 2 login shenanigans
    cout << "\nPLAYER 2 (LowerCase/Black):\n";
    while (true) {
        int choice = menu.navigateMenu();
        if (choice == 1) {
            if (player2.login() && player2.getUsername() != player1.getUsername()) break;
            if (player2.getUsername() == player1.getUsername()) {
                cout << "Same user cannot play against themselves. Please log in with a different account.\n";
                menu.pause();
            } else {
                menu.pause();
            }
        } else if (choice == 2) {
            player2.registerUser();
            menu.pause();
        } else {
            cout << "Exiting...\n";
            return 0;
        }
    }

    // Start game
    system("cls");
    cout << "==============================\n";
    cout << "     Welcome to CLI Chess     \n";
    cout << "==============================\n";
    cout << "\nMatch setup:\n";
    cout << "White (UpperCase): " << player1.getUsername() << " (ELO: " << player1.getElo() << ")\n";
    cout << "Black (LowerCase): " << player2.getUsername() << " (ELO: " << player2.getElo() << ")\n\n";
    cout << "Press any key to start the game...";
    _getch();

    ChessGame game(&player1, &player2);
    game.play();

    return 0;
}
